var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PolyesterWeave","category":"page"},{"location":"#PolyesterWeave","page":"Home","title":"PolyesterWeave","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PolyesterWeave.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PolyesterWeave]","category":"page"},{"location":"#PolyesterWeave.UnsignedIteratorEarlyStop","page":"Home","title":"PolyesterWeave.UnsignedIteratorEarlyStop","text":"UnsignedIteratorEarlyStop(thread_mask[, num_threads = count_ones(thread_mask)])\n\nIterator, returning (i,t) = Tuple{UInt32,UInt32}, where i iterates from 1,2,...,num_threads, and t gives the threadids to call ThreadingUtilities.taskpointer with.\n\nUnfortunately, codegen is suboptimal when used in the ergonomic for (i,tid) âˆˆ thread_iterator fashion. If you want to microoptimize, You'd get better performance from a pattern like:\n\nfunction sumk(u,l = count_ones(u) % UInt32)\n    uu = ServiceSolicitation.UnsignedIteratorEarlyStop(u,l)\n    s = zero(UInt32); state = ServiceSolicitation.initial_state(uu)\n    while true\n        iter = iterate(uu, state)\n        iter === nothing && break\n        (i,t),state = iter\n        s += t\n    end\n    s\nend\n\nThis iterator will iterate at least once; it's important to check and exit early with a single threaded version.\n\n\n\n\n\n","category":"type"},{"location":"#PolyesterWeave.disable_polyester_threads-Tuple{F} where F","page":"Home","title":"PolyesterWeave.disable_polyester_threads","text":"disable_polyester_threads(f::F)\n\nA context manager function that disables Polyester threads without affecting the scheduling of Base.Treads.@threads. Particularly useful for cases when Polyester has been used to multithread an inner small problem that is now to be used in an outer embarassingly parallel problem (in such cases it is best to multithread only at the outermost level).\n\nThis call will disable all PolyesterWeave threads, including those in LoopVectorization.@tturbo and Octavian.matmul.\n\nAvoid calling it as @threads for i in 1:n disable_polyester_threads(f) end as that creates unnecessary per-thread overhead. Rather call it in the outermost scope, e.g. as given here:\n\ndisable_polyester_threads() do\n    @threads for i in 1:n f()\nend\n\n\n\n\n\n","category":"method"}]
}
