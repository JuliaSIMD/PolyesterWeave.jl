var documenterSearchIndex = {"docs":
[{"location":"","page":"Home","title":"Home","text":"CurrentModule = PolyesterWeave","category":"page"},{"location":"#PolyesterWeave","page":"Home","title":"PolyesterWeave","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for PolyesterWeave.","category":"page"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"","page":"Home","title":"Home","text":"Modules = [PolyesterWeave]","category":"page"},{"location":"#PolyesterWeave.UnsignedIteratorEarlyStop","page":"Home","title":"PolyesterWeave.UnsignedIteratorEarlyStop","text":"UnsignedIteratorEarlyStop(thread_mask[, num_threads = count_ones(thread_mask)])\n\nIterator, returning (i,t) = Tuple{UInt32,UInt32}, where i iterates from 1,2,...,num_threads, and t gives the threadids to call ThreadingUtilities.taskpointer with.\n\nUnfortunately, codegen is suboptimal when used in the ergonomic for (i,tid) âˆˆ thread_iterator fashion. If you want to microoptimize, You'd get better performance from a pattern like:\n\nfunction sumk(u, l = count_ones(u) % UInt32)\n  uu = ServiceSolicitation.UnsignedIteratorEarlyStop(u, l)\n  s = zero(UInt32)\n  state = ServiceSolicitation.initial_state(uu)\n  while true\n    iter = iterate(uu, state)\n    iter === nothing && break\n    (i, t), state = iter\n    s += t\n  end\n  s\nend\n\nThis iterator will iterate at least once; it's important to check and exit early with a single threaded version.\n\n\n\n\n\n","category":"type"},{"location":"#PolyesterWeave.disable_polyester_threads-Tuple{F} where F","page":"Home","title":"PolyesterWeave.disable_polyester_threads","text":"disable_polyester_threads(f::F)\n\nA context manager function that disables Polyester threads without affecting the scheduling of Base.Treads.@threads. Particularly useful for cases when Polyester has been used to multithread an inner small problem that is now to be used in an outer embarassingly parallel problem (in such cases it is best to multithread only at the outermost level).\n\nThis call will disable all PolyesterWeave threads, including those in LoopVectorization.@tturbo and Octavian.matmul.\n\nAvoid calling it as @threads for i in 1:n disable_polyester_threads(f) end as that creates unnecessary per-thread overhead. Rather call it in the outermost scope, e.g. as given here:\n\ndisable_polyester_threads() do\n    @threads for i in 1:n f()\nend\n\n\n\n\n\n","category":"method"},{"location":"#PolyesterWeave.request_threads","page":"Home","title":"PolyesterWeave.request_threads","text":"request_threads is called to request a set of ThreadingUtilities worker tasks to run on.\n\njulia> using PolyesterWeave\n\njulia> PolyesterWeave.request_threads(12)\n((Thread (12) Iterator: U[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12],), (0x0000000000000fff,))\n\nThis returns an iterator over the available threads 1-12 U[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12], as well as a mask that must be used for freeing these threads when done.\n\nNote that the thread doing the requesting should also always do part of the work. Thus if you want to run on 13 threads, you'd request 12. If you want to run on 8 threads, you'd request 7. Etc.\n\nIf you request more threads than available on the system, you get only what is available:\n\njulia> Sys.CPU_THREADS, Threads.nthreads()\n(16, 8)\n\njulia> r1 = PolyesterWeave.request_threads(30) # Note you get only 7, not 8\n((Thread (7) Iterator: U[1, 2, 3, 4, 5, 6, 7],), (0x000000000000007f,))\n\njulia> r2 = PolyesterWeave.request_threads(30)\n((Thread (0) Iterator: UInt64[],), (0x0000000000000000,))\n\nThe following are unsupported features that might be yanked out at any time:\n\nDuring request you can also mask out which threads you can get. For instance, this call:\n\njulia> Sys.CPU_THREADS, Threads.nthreads()\n(96, 96)\n\njulia> r1 = PolyesterWeave.request_threads(96, 0xa)\n((Thread (2) Iterator: U[2, 4], Thread (31) Iterator: U[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31]), (0x000000000000000a, 0x000000007fffffff))\n\nIs saying you want 96 threads, but you have the mask 0x0a which turns off all threads from the first set of 64 except for 2 and 4:\n\njulia> bitstring(0xa)\n\"00001010\"\n\nHence you got the iterator U[2,4], plus an iterator over all the available works from the next batch of 64.\n\n\n\n\n\n","category":"function"}]
}
